# Maven聚合

## 环境准备

先从Maven模块聚合开始，因为它们底层逻辑是差不多的

1. 首先现在磁盘中建立一个文件夹，取好名字后如Maven打开

2. 然后如图所示创建一个**SpringBoot**（3.3.4）项目![模块](./3.微服务基础.assets/QQ20241030-111042.png)

   在SpringBoot中勾选上SpringWeb的依赖

3. 要建立**两个项目**，建好后如图所示![项目结构](./3.微服务基础.assets/6f74b19d-3adf-4b16-b727-a8379e89704d.png)

4. 然后在第一个**test1项目**中**建立一个网络接口类**

   ```java
   import org.springframework.web.bind.annotation.GetMapping;
   import org.springframework.web.bind.annotation.RequestMapping;
   import org.springframework.web.bind.annotation.RestController;
   
   @RestController
   @RequestMapping("test1")
   public class test1 {
       @GetMapping("1")
       public String test1(){
           return "我是test1项目";
       }
   }
   ```

5. 然后在**第二个项目也建立一个这样的类**。然后**启动两个项目**，当然**第二个项目**的**端口号要记得修改**

6. 然后进入[项目1](http://localhost:8080/test1/1)和[项目2](http://localhost:8081/test1/1)测试一下，如果**都能打开**，那么**环境**就**配置成功**

## *服务治理

现在我们这个项目有**两个**这样的**模块（微服务）**，但是**模块业务之间**，如果有**数据交流该如何实现？**

目前它们的**物理位置上是隔离**的，我们该怎么交流数据呢？

其实我们之前就已经做个这样的功能，那就是项目开发的时候，前后端分离，**前端通过Ajax后端通过Servlet达到信息传输**。那么现在后端变前端，用前端的方式传给后端获取数据，这样就可以做到信息交流。

好现在信息传输问题是解决了。但在现实中，可能某个服务很热门，为了缓解压力，**会多开几个端口**，那么问题来了，多开几个端口，**那怎么选接口呢？**如果某个服务端口挂了，那你**万一选中**的正好就是**挂掉的端口**又该怎么办？如果公司新买了几台服务器，难不成还得改动源代码去重新打包编译部署吗？

总结一下现在的问题：

1. **动态获取接口地址**
2. **筛选出接口好坏**
3. **接口负载均衡**
4. **发送网络请求**

这四种问题综合一起，在微服务中，就被称为**服务治理**

### 注册中心

我们可以通过一个专门管理接口地址的**注册中心**获取**可用端口**，这样就能筛选出不可用的接口，因为注册中心会通过心跳（定期发送请求给注册中心）来判断接口是否可用。

#### Nacos注册中心

阿里巴巴开源的的注册中心组件，SpringCloud下有非常多的注册中心组件，那为什么要选Nacos呢？

因为是国产，**文档教程**和技术讨论以及社区热度都很高。重要的是这些组件都是**遵从SpringCloud的接口标准**，虽然底层可能不一样，但是封装好后的使用方法基本都差不多

##### 环境配置

[官方文档](https://nacos.io/docs/latest/quickstart/quick-start/)

注意！这个是在**Linux环境配置**的，但为了方便，就在**Windows环境安装**

1. 首先第一步，当然是去[官网](https://nacos.io/download/nacos-server/)下载Nacos压缩包，这个笔记中，采用的是**2.4.3**版本

2. 然后将它解压，进入文件目录=>conf找到mysql-schema.sql这个文件

3. 找到后**打开Navicat数据库软件**（使用idea也行，但是你得在每个表名上加上一个数据库名称，不然无法执行代码），然后**新建一个库叫Nacos**，然后在库中新建一个查询，然后把刚才的**.sql文件打开**，把里面**所有东西复制粘贴到查询窗口上**，然后**运行代码**，运行结束后吗的库表应该和我一致![数据库](./3.微服务基础.assets/b486170d-74bb-41f7-8a94-ee54120f8cfd.png)

4. 然后在**文件目录下的bin文件下**，**新键一个cmd程序**，代码如下

   ```cmd
   startup.cmd -m standalone
   ```

5. 然后运行这个写好的cmd，那么Nacos就会启动，当你cmd窗口停在

   ```
   Nacos started successfully in stand alone mode. use embedded storage
   ```

   这段话后不动，就说你**Nacos启动成功**

6. 然后在输入这段地址，就能进入控制台（如果有密码，那账号和密码默认是nacos）

   ```
   http://127.0.0.1:8848/nacos
   ```

   当然这是**默认地址**，你没动过配置文件的情况下

7. 然后在bin的界面下，找到**shutdown.cmd**这个文件，**点击运行后就能关闭Nacos服务**

##### 服务注册

10. 现在**注册中心搭建好**了，那现在就该让自己**项目的端口注册到注册中心**被引用

    1. 先启动好Nacos服务，然后打开控制台停在**服务管理=>服务列表**这一页面
    
    2. 然后创建一个springboot带**mvc**依赖的项目
    
    3. 然后向两个创建的项目的**pom文件**添加maven坐标
    
       ```xml
               <!-- Nacos服务 -->
               <dependency>
                   <groupId>com.alibaba.cloud</groupId>
                   <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
                   <version>2023.0.1.2</version>
               </dependency>
       
               <!-- SpringCloud核心 -->
               <dependency>
                   <groupId>org.springframework.cloud</groupId>
                   <artifactId>spring-cloud-dependencies</artifactId>
                   <version>2023.0.2</version>
                   <type>pom</type>
                   <scope>import</scope>
               </dependency>
       ```
    
    4. 之后修改配置文件为
    
       ```yaml
       spring:
         application:
           name: test1
         cloud:
           nacos:
             discovery:
               server-addr: 127.0.0.1:8848
       server:
         port: 8081
       ```
    
    5. 添加后启动两个项目回到Nacos控制台页面刷新，你就会发现列表已经出现**两个服务**，**说明服务注册成功**
    
    6. **还没完**，因为实际项目中，**一个模块服务会有多个实例**，因此我们也需要进行相对于的配置
    
    7. 首先打开这个设置![idea](./3.微服务基础.assets/QQ20241030-215407-1732065723266-3.png)
    
    8. 然后框选要复制的项目，然后点击一下![idea](./3.微服务基础.assets/QQ20241030-215526-1732065723266-7.png)
    
    9. 然后**修改**一下**名称**，然后再点击一下这个界面的**修改选项**（有高亮显示），点击添加**虚拟机选项**![idea](./3.微服务基础.assets/QQ20241030-215648-1732065723266-4.png)
    
    10. 然后在里面添加上这段代码，**等于号后面就是端口号**
    
       ```
    -Dserver.port=8083
       ```
    
    11. 然后在外面启动这个项目![idea](./3.微服务基础.assets/QQ20241030-215926-1732065723266-6.png)
    
    12. 然后去到**Nacos页面**，刷新一下，就会发现实例从1变成2![4f86e5ac-1f73-455c-8f4e-c9cd41695190](./../../图床/4f86e5ac-1f73-455c-8f4e-c9cd41695190-1732065723266-5.png)
    
        说明**多例项目设置完成**

### 负载均衡

现在解决了筛选端口的问题，那么如何解决选择可用端口的问题呢？为了避免请求过于集中，因此我们需要做**负载均衡算法**，让各个接口的请求数量来看是基本一致，最大化利用性能。

1. 随机：就是字面意思，**随机选择一个接口**，在短时间内可能会造成单个接口负载过大，但是长期来看，基本是能做到负载均衡这点。
2. 加权随机：也是字面意思，**会根据  接口数量和接口性能等方面，来做不同概率随机**，比如高性能服务器的接口就能大概率被选中，低性能的接口就小概率被选中。也能做到负载均衡效果
3. 轮询：也是字面意思，abc三个接口，轮流发送请求

### OpenFeign

在上面的例子中，我们已经解决了**动态获取接口**和**负载均衡**的问题，现在只剩最后一个问题了，就是如何**发送请求**

一个声明式Http客户端，**专门来做http请求**

#### 快速入门

这里写一个简单的例子，快速上手使用**OpenFeign**

1. 在一个需要发送请求的项目的pom文件中导入Maven依赖

   ```xml
           <!-- OpenFeign 用来做http协议服务 -->
           <dependency>
               <groupId>org.springframework.cloud</groupId>
               <artifactId>spring-cloud-starter-openfeign</artifactId>
               <version>4.1.3</version>
           </dependency>
   
           <!-- 负载均衡算法库 -->
           <dependency>
               <groupId>org.springframework.cloud</groupId>
               <artifactId>spring-cloud-starter-loadbalancer</artifactId>
               <version>4.1.3</version>
           </dependency>
   ```

2. 导入完成后，去新建一个**请求发送接口**

   ```java
   import org.springframework.cloud.openfeign.FeignClient;
   import org.springframework.web.bind.annotation.GetMapping;
   
   //这个注解的作用是标记服务名称
   //服务名称是Nacos里面的登记的名称
   @FeignClient(value = "test2")
   public interface reqTest1 {
       //注解和SpringMvc使用逻辑差不多
       //你要以什么请求方式发送就写对应的注解
       //注解的括号填写则是完整的请求接口地址
       //不包括前面的IP地址，因为OpenFeign会和Nacos联动动态获取
       @GetMapping("test1/1")
       String test();
   
   }
   ```

3. 然后稍微**修改**一下**网络请求类**

   ```java
   @RestController
   @RequestMapping("test1")
   public class test1 {
       //通过Spring注入服务
       @Autowired
       private reqTest1 reqTest1;
   
       @GetMapping("1")
       public String test1(){
           //通过动态带来方式，直接就能点出方法使用
           return "我成功获取到"+reqTest1.test();
       }
   }
   ```

4. 然后去修改一下**被请求**的**项目接口内容**

   ```java
   import org.springframework.web.bind.annotation.GetMapping;
   import org.springframework.web.bind.annotation.RequestMapping;
   import org.springframework.web.bind.annotation.RestController;
   
   @RestController
   @RequestMapping("test1")
   public class test1 {
       @GetMapping("1")
       public String test1(){
           System.out.println("有人进来了");
           return "test2项目";
       }
   }
   ```

   注意，被请求的项目，是可以不用导入上面的两个依赖的

5. 然后启动要**被请求项目两个实例**

6. 然后去到**请求项目**中，在**SpringBoot启动类**中**带上**一个这样的**注解**，然后启动项目

   ```java
   import org.springframework.boot.SpringApplication;
   import org.springframework.boot.autoconfigure.SpringBootApplication;
   import org.springframework.cloud.openfeign.EnableFeignClients;
   
   //意思就是启动OpenFeign
   @EnableFeignClients
   @SpringBootApplication
   public class Test1Application {
   
       public static void main(String[] args) {
           SpringApplication.run(Test1Application.class, args);
       }
   
   }
   ```

7. 然后浏览器进入[请求项目地址](http://localhost:8080/test1/1)

8. 如果能够正常打印，就多刷新几次，然后回到idea控制台，![控制台](./3.微服务基础.assets/20364665-99e0-4ed3-8689-303a8f402385.png)如果两个**被请求项目实例**都能打印出文字，说明负载均衡也成功。

那么到这，**服务治理问题，算是初步解决完毕**

##### 有参请求

上面的入门案例是无参请求，这里简单演示一下有参请求的写法

1. 假设**被请求的方法**上面需要**一个参数**传递，例如

   ```java
   import org.springframework.web.bind.annotation.GetMapping;
   import org.springframework.web.bind.annotation.RequestMapping;
   import org.springframework.web.bind.annotation.RestController;
   
   @RestController
   @RequestMapping("test1")
   public class test1 {
       @GetMapping("1")
       //需要一个name的String类型
       public String test1(String name) {
           System.out.println(name);
           return "test2项目";
       }
   }
   ```

2. 那么我们的**请求方法**就得这样写

   ```java
   import org.springframework.cloud.openfeign.FeignClient;
   import org.springframework.web.bind.annotation.GetMapping;
   import org.springframework.web.bind.annotation.RequestParam;
   
   
   @FeignClient(value = "test2")
   public interface reqTest1 {
       @GetMapping("test1/1")
       //@Re......param这个注解标记的是对应被请求方法的形参名称
       //简单来说就说网址名后的?name=苹果
       //如果注解形参故意写错，那么被请求方法就无法接受到数据
       //注解后面的数据类型也必须相同，但是形参则可以自定义
       String test(@RequestParam("name") String name);
   
   }
   ```

3. 然后**重启两个项目**，**被请求方法就能接受到参数**![控制台](./3.微服务基础.assets/ed76cca7-3b01-42ed-9ca2-52cfadf3c13a.png)

这就是有参请求的写法，那么下面就是传递多个参数的写法

- 其实没有什么变化，也是一样的方式，这里仅贴出代码来大概演示，不手把手带着写

  ```java
  import org.springframework.cloud.openfeign.FeignClient;
  import org.springframework.web.bind.annotation.GetMapping;
  import org.springframework.web.bind.annotation.RequestParam;
  
  
  @FeignClient(value = "test2")
  public interface reqTest1 {
      @GetMapping("test1/1")
      String test(@RequestParam("name") String name,@RequestParam("age") Integer age);
  
  }
  ```

##### Post请求

上面的都是**Get请求**，那**Post请求**该如何写呢？

答案也是很简单，把代码稍作修改即可

1. 这是**请求方法**

   ```java
   import org.springframework.cloud.openfeign.FeignClient;
   import org.springframework.web.bind.annotation.PostMapping;
   import org.springframework.web.bind.annotation.RequestBody;
   
   
   @FeignClient(value = "test2")
   public interface reqTest1 {
       //修改为post
       @PostMapping("test1/1")
       //将变量放入请求体中
       String test(@RequestBody String name);
   
   }
   ```

2. 这是**被请求方法**

   ```java
   import org.springframework.web.bind.annotation.*;
   
   @RestController
   @RequestMapping("test1")
   public class test1 {
       //接受post请求
       @PostMapping("1")
       //获取请求体参数
       public String test1(@RequestBody String name) {
           System.out.println(name);
           return "test2项目";
       }
   }
   ```

这样就实现了Post请求，但如果你想请求**多个Post参数**，则需要把它们**打包成对象**进行传递，这里就不做演示

#### 原理和优化

OpenFeign自动实现了从**Nacos获取接口列表**、**负载均衡**、**动态代理简化请求方法代码**

那么具体是如何做到呢？

可以观看这个视频[OpenFeign自动代理简单源码分析](https://www.bilibili.com/video/BV1S142197x7?spm_id_from=333.788.videopod.episodes&vd_source=95c95b2b45956217a529f886ca23dd35&p=51)

那么现在原理大概理清楚，**OpenFeign底层发送请求，每次发送都需要创建和销毁**，效率低下，因此**需要连接池技术，优化性能**

OpenFeign默认使用**HttpURLConnection**实现，这个技术是不支持连接池技术的

但是它提供了一个接口，可以让我们自定义从而支持连接池技术

以下两种都是常见的连接池技术

1. Apache HttpClient
2. OKHttp

##### 配置连接池

这里将以第二种，OKhttp来做连接池配置

1. 在**发送请求项目**的maven环境中导入依赖

   ```xml
           <!-- 实现OpenFeign的连接池技术 -->
           <dependency>
               <groupId>com.squareup.okhttp3</groupId>
               <artifactId>okhttp</artifactId>
               <version>5.0.0-alpha.14</version>
           </dependency>
   ```

2. 然后在**配置文件**（这里是**properties类型**）加上

   ```properties
   spring.cloud.openfeign.okhttp.enabled=true
   ```

3. 然后启动项目（是的你没看错，就是这么简单），然后访问请求没有任何问题，就说明已经成功配置完成

#### *使用标准

在行业中，使用**OpenFeign**是有使用规范，也可以是标准，再简单来说按着标准模板使用

我们先看看我们上面使用例子有什么问题？

比如说，如果**同一个接口**，需要**多个项目去访问**，那岂不是所有项目都得写一遍这个接口代码？

再比如，万一接口代码动了，那这些所有代码也得跟着修改

因此我们需要优化一下我们的代码

目前有两种解决方案，假设现在有一个场景，b项目要访问a项目内容

1. 分模块：请求方法就由a项目的人自己写，b项目通过maven坐标去获取直接调方法。简单来说就是**别人需要什么，你就写什么给别人**
2. 抽取公共方法：a和b项目都别写，专门开一个新项目c，所有请求方法全部交给c完成。简单来说就是**开一个专门负责写请求的项目**

在企业大项目中，往往会采用第一种方法，因为这种方法耦合最低，并且写代码的都是最了解的自己人所写。但是也不是没有缺点，会导致项目结构复杂，假如一个项目10个微服务，每个微服务又要开三个模块，那总计30个模块服务

而第二种，则相对来说会简单一点，但耦合相对也会提升，并且是项目以外的人编写代码

究竟是选择哪一种呢？

如果你是每个微服务是一个个**独立Project**，那么就把低耦合发挥到极致，就**采用第一种**

如果你是通过**maven聚合**工程开发，这种天然就带有一定的耦合性，那就没必要为了低耦合而低耦合，就**采用第二种**

##### 抽取公共方法

由于当前笔记使用的是Maven聚合，所以自然选择第二种方法

1. 首先新建一个模块（**注意！这个模块是专门负责API方法，因此它不需要去启动，但是由于这个项目不是建立在一个SpringBoot的父类maven项目下，因此会缺少很多依赖，所以在这里是以SpringBoot的项目创建，勾选SpringMvc**）

2. 然后把之前写请求方法的项目的pom文件依赖和请求方法的接口全都挪到**新建的模块下**

3. 别忘记配置文件中的**配置连接池**也要转移过去

4. 然后在**原本写请求方法**的**pom文件**上加上新建模块的依赖（引用）

   ```xml
           <!-- apiTest1的项目 -->
           <dependency>
               <groupId>com.zzz</groupId>
               <artifactId>apiTest1</artifactId>
               <version>0.0.1-SNAPSHOT</version>
               <scope>compile</scope>
           </dependency>
   ```

5. 然后在**请求方法项目**的SpringBoot启动类中上面的注解，**写明扫描范围**

   ```java
   import org.springframework.boot.SpringApplication;
   import org.springframework.boot.autoconfigure.SpringBootApplication;
   import org.springframework.cloud.openfeign.EnableFeignClients;
   
   //OpenFeign扫描范围声明，不写Spring就获取不到bean对象，就无法自动装配
   @EnableFeignClients(basePackages = "com.zzz.apitest1")
   @SpringBootApplication
   public class Test1Application {
   
       public static void main(String[] args) {
           SpringApplication.run(Test1Application.class, args);
       }
   
   }
   ```

6. 最后再修改一下请求方法类中的**接口位置**就行

   ```java
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.web.bind.annotation.GetMapping;
   import org.springframework.web.bind.annotation.RequestMapping;
   import org.springframework.web.bind.annotation.RestController;
   
   @RestController
   @RequestMapping("test1")
   public class test1 {
       //声明是来自于apiTest1项目中的接口
       @Autowired
       private com.zzz.apitest1.reqTest1 reqTest1;
   
       @GetMapping("1")
       public String test1(){
           //通过动态带来方式，直接就能点出方法使用
           return "我成功获取到"+reqTest1.test("苹果");
       }
   }
   ```

7. 最后启动项目，访问一下网址，能获取到信息说明**修改完成**

#### OpenFeign日志

日志在项目开发中，是相当重要的，因为它能快速定位问题所在，因此在生产环境下，需要在**合适的地方输出合适的日志内容**

OpenFeign只会在FeignClient所在包的日志级别为DeBug时候，才会打印日志

但是OpenFeign默认是为不做日志记录

总结一下就是想要输出OpenFeign的日志，我们要**做到两点**

1. 修改FeignClient的日志级别为DeBug级
2. 修改OpenFeign的日志默认值 

另外OpenFeign也是有**日志级别**的

1. NONE:不做任何记录，**默认值**
2. BASIC:记录请求方法、URL、响应状态码和执行时间
3. HEADERS:额外增加请求和响应头信息
4. FULL:记录一切

##### 修改日志等级

首先修改日志级别，要在请求方法模块中实现，而不是具体的微服务，因为可能大部分微服务都需要开启

[该功能在当时无法实现，相信后人的智慧，这个是参考视频](https://www.bilibili.com/video/BV1S142197x7?spm_id_from=333.788.player.switch&vd_source=95c95b2b45956217a529f886ca23dd35&p=53)

## *网关配置

在**后端和后端请求**之间，我们有**Nacos**帮我们完成接口的**发布、筛选、动态获取**

那么问题来了，**前端怎么办？**

再比如说，如果登录的验证信息，所有微服务都需要了？难道每个微服务都做一份检验拦截器？

那么现在微服务组件中就有一个解决这个问题的方案：**网关**

简单来说，网关就是网络的入口，负责**路由、转发、身份校验等功能**

那么**网关**是**如何获取到后端这些动态接口呢？**

答案很简单，**直接去找Nacos要就行了**

配置了网关之后，前端只需要网关的网络ip地址即可，通过网关去做身份检验和路由到目标接口

目前比较主流的网关实现有两种

1. Spring Cloud Gateway：Spring开源，基于WebFlux响应式编程，性能优异
2. Netfilx Zuul：美国奈飞公司产品。基于Servlet阻塞式编程，需要优化

显然对比下来Spring家的产品更加优秀，因此下面学习也是基于Spring

### 快速入门

首先得完成两步，分别是**网关环境搭建**和**网关规则**

1. 首先新建一个网关项目（采用**SpringBoot3.3.4**）

2. 然后添加下面的**依赖**

   ```xml
           <!-- SpringCloud网关 -->
           <dependency>
               <groupId>org.springframework.cloud</groupId>
               <artifactId>spring-cloud-starter-gateway</artifactId>
               <version>4.1.5</version>
           </dependency>
   
           <!-- Nacos服务 -->
           <dependency>
               <groupId>com.alibaba.cloud</groupId>
               <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
               <version>2023.0.1.2</version>
           </dependency>
   
           <!-- SpringCloud核心 -->
           <dependency>
               <groupId>org.springframework.cloud</groupId>
               <artifactId>spring-cloud-dependencies</artifactId>
               <version>2023.0.2</version>
               <type>pom</type>
               <scope>import</scope>
           </dependency>
   
           <!-- 负载均衡算法库 -->
           <dependency>
               <groupId>org.springframework.cloud</groupId>
               <artifactId>spring-cloud-starter-loadbalancer</artifactId>
               <version>4.1.3</version>
           </dependency>
   ```

3. 添加后，**启动Nacos服务**

4. 然后去到**网关**的**配置文件**加上这段内容

   ```yaml
   spring:
     application:
       name: gatewayTest1                      #启动后的项目名称
     cloud:
       nacos:
         server-addr: 127.0.0.1:8848           #Nacos的网络地址
       gateway:
         routes:                               #要网关路由到对应的微服务的配置
           - id: test2                         #要路由到的ID，这里填写的是以项目的配置文件名称为准，和你要路由到的微服务有关
             uri: lb://test2                   #路由到的路径
             predicates:                       #断言，就是匹配规则，lb就是采取复杂均衡策略
               - Path=/test1/**                #意思就是只要请求进来的接口，是test1下的，就能进来，这个和你对应项目的web层有关
             # - Path=/test1/**,/test2/**      #如果想要配多个的话，可以像这样写
     main:
       web-application-type: reactive          #设置web框架，如果你网关项目有SpringMvc依赖，就必须加上这个，如果不是就删掉
   server:
     port: 8083                                #项目端口号
   ```

5. 根据**配置文件**的**注释**，**自己调整一下**

6. 然后写完后就直接**启动网关项目**，然后**启动网关会路由到的项目**

7. 然后[输入这个地址](http://localhost:8083/test1/2)如果有能够正确访问，那么路由**网关搭建完成**

可以试着**停掉一个请求方法项目**，然后需要**去Nacos刷新点查询刷新一下**，不然网关会访问停机的服务器中

点了Nacos刷新后再来这个页面，你会发现**网关依然能正常访问**

**并且网关还实现了负载均衡的效果**

### 路由配置

刚才的入门案例属于**最基本的网关配置**，但这些基础配置**还远远不够**

1. **id**：路由唯一标识
2. **uri**：路由目标地址
3. **predicates**：路由断言，判断请求是否符合当前路由
   - 断言的基本属性有![路由属性](./3.微服务基础.assets/35d2d7c8-27d6-4610-8e1b-2d3f908bd7d7.png)
4. **filters**：路由过滤器，对请求和响应做特殊处理
   - 基本的过滤属性![过滤属性](./3.微服务基础.assets/53fb7fe3-c396-4097-a569-3ecaf1961773.png)

#### 过滤器

**很多业务是需要登录后，带着token来才可以访问**，因此需要**在网关处进行检验检查**，那么具体该怎么检查呢？

- 如图，这是网关处理的大致逻辑![网关源码](./3.微服务基础.assets/02bf0d89-ee1f-4658-ba7f-93fbf99cbef1.png)

##### 自定义过滤器

网关过滤器有两种

1. GatewayFilter：**路由过滤器**，能指定任意路由，**默认不生效**，要配置到路由后生效
2. Globalfilter：**全局过滤器**，能作用在所有路由中，**声明后自动生效**

这里分别演示下两种的过滤器，首先先从Globalfilter开始

- 这是路由过滤器，在网关项目新建一个**过滤器类**

  ```java
  import org.springframework.cloud.gateway.filter.GatewayFilterChain;
  import org.springframework.core.Ordered;
  import org.springframework.http.server.reactive.ServerHttpRequest;
  import org.springframework.stereotype.Component;
  import org.springframework.web.server.ServerWebExchange;
  import reactor.core.publisher.Mono;
  
  @Component
  public class GlobalFilter implements org.springframework.cloud.gateway.filter.GlobalFilter, Ordered {
      @Override
      public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
          //获取请求的参数
          ServerHttpRequest request = exchange.getRequest();
          //打印请求头信息
          System.out.println("请求头是"+request.getHeaders());
          //放行
          return chain.filter(exchange);
      }
  
      /**
       * 设置执行优先级
       */
      @Override
      public int getOrder() {
          return 0;
      }
  }
  ```

写完后，重启下项目，通过网关走进的请求，就能看见请求头了

**通常使用路由过滤器，就能应付大部分业务场景**，而全局过滤器实现比较麻烦

[如果你有需要，就点我](https://www.bilibili.com/video/BV1S142197x7?spm_id_from=333.788.videopod.episodes&vd_source=95c95b2b45956217a529f886ca23dd35&p=63)

#### 网关传递用户

光是网关拿到信息还不够，因为**真正做业务处理**的是各种各样的**微服务**，因此还需要把**信息传给微服务**

那么如何传递到呢？在网关的时候，我们可以将它写在请求头上

1. 首先在网关获取到请求的时候，就添加上请求头信息

   ```java
   import org.springframework.cloud.gateway.filter.GatewayFilterChain;
   import org.springframework.core.Ordered;
   import org.springframework.http.server.reactive.ServerHttpRequest;
   import org.springframework.stereotype.Component;
   import org.springframework.web.server.ServerWebExchange;
   import reactor.core.publisher.Mono;
   
   @Component
   public class GlobalFilter implements org.springframework.cloud.gateway.filter.GlobalFilter, Ordered {
       @Override
       public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
           //修改请求头参数，这个sb是要和微服务部分统一，一般会使用常量
           exchange.mutate().request(builder -> builder.header("sb","BigApple")).build();
           //放行
           return chain.filter(exchange);
       }
   
       /**
        * 设置执行优先级
        */
       @Override
       public int getOrder() {
           return 0;
       }
   }
   ```

2. 然后在微服务里面接受请求头参数

   ```java
   @GetMapping("2")
       //第一个value就是请求头名
       //第二个是不一定能接受到
       public String test2(@RequestHeader(value = "sb",required = false) String sb) {
           System.out.println(sb);
           return "路由配置成功";
       }
   ```

3. 然后**还没完**，因为这种方式相当于**所有方法都得验证一遍**，所以需要抽出公共方法，在**公共项目中写拦截器代码**，获取到后**存入ThreadLocal线程变量中**

4. 由于环境问题，暂时无法实现，在这[标记](https://www.bilibili.com/video/BV1S142197x7?spm_id_from=333.788.player.switch&vd_source=95c95b2b45956217a529f886ca23dd35&p=65)一下相信后人智慧

#### 微服务信息传输

环境问题，相信后人[智慧](https://www.bilibili.com/video/BV1S142197x7?spm_id_from=333.788.videopod.episodes&vd_source=95c95b2b45956217a529f886ca23dd35&p=66)

### 配置管理

当你把这一章节学完，那么**微服务就可以进行开发**，当然，**依然会存在问题**，只不过都是些小问题，可以不理会

微服务可能会有几十个甚至上百，那么你就需要配置相对于的数据配置，如果将来要修改也是相当困难

解决方法，就是使用**配置管理服务**将通用配置都记录在这里面，而**配置管理服务**通过推送服务，让微服务获取数据，这样修改配置信息就不需要重新打包编译部署

那么**配置管理服务**具体是什么呢？

没错就是**Nacos**，Nacos除了具有注册中心功能，还有**配置管理服务功能**

#### 配置共享

但是现在又有个问题，那就是**我SpringBoot项目得先启动，启动后才能去拉取配置信息，可问题是我都启动完了，还读取个屁的配置**，这不是陷入了鸡蛋悖论（先有鸡还是先有蛋）问题？

为了解决这个问题，SpringBoot提供了一种配置文件，叫做**引导配置**

- 如图所示**![配置](./3.微服务基础.assets/bf2f8f0b-afd3-46b5-9e92-ae638680fb47.png)配置文件由SpringCloud读取**，然后通过SpringCloud去启动SpringBoot项目

1. 首先先启动Nacos，然后创建一个springBoot的mvc项目

2. 然后在pom文件添加依赖

   ```xml
           <!-- nacos拉取配置文件 -->
           <dependency>
               <groupId>com.alibaba.cloud</groupId>
               <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
               <version>2023.0.1.2</version>
           </dependency>
   
           <!-- boostrap配置文件引导启动 -->
           <dependency>
               <groupId>org.springframework.cloud</groupId>
               <artifactId>spring-cloud-starter-bootstrap</artifactId>
               <version>4.0.4</version>
           </dependency>
   ```

3. 然后在配置nacos上发布配置,如图![17d5155f-4cea-47ce-9da7-9e1b7c874d79](./3.微服务基础.assets/17d5155f-4cea-47ce-9da7-9e1b7c874d79.png)注意其中的id，必须带个“.文件格式”的后缀名，不然是拉取不到配置的

4. 这里我填写的信息，这里我上传的是jdbc配置，从nacos拉取配置做数据库操作

5. 然后重写springboot的application.yml配置文件

   ```yaml
   spring:
     application:
       name: SteamUserEmailVerify
   server:
     port: 8082
   ```

6. 之后在这个配置文件的下面新建一个文件bootstrap.yml

   ```yaml
   spring:
     cloud:
       nacos:
         server-addr: 127.0.0.1:8848
         config:
           server-addr: 127.0.0.1:8848       # 拉取配置的网址
           shared-configs:
             - data-id: MysqlAndRedis.yaml   # 刚才在控制台写的id
   ```
   
7. 之后把需要进行测试代码完成，然后启动程序测试我们能看见一些信息-->![5a2e5300-e0c7-465e-a8e8-9c0a4b0a1263](./3.微服务基础.assets/5a2e5300-e0c7-465e-a8e8-9c0a4b0a1263.png)

5. 看见这个后，基本就稳了，**因为如果你也是采用拉取jdbc的配置的话，如果没拉到，项目是无法启动的**

#### 热更新

既然现在配置获取到了，那么如果我想在**不重启项目的情况下更新配置怎么办**？

由于环境问题，具体实现过程相信后人[智慧](https://www.bilibili.com/video/BV1S142197x7?spm_id_from=333.788.player.switch&vd_source=95c95b2b45956217a529f886ca23dd35&p=69)

#### *动态路由

网关作为整个微服务入口，是不能关闭和重启的，但如果想进行配置更改该怎么办？

这就需要Nacos进行动态路由设置

1. 首先，先在网关项目下导入Maven的依赖

   ```xml
           <!-- 从Nacos获取配置文件依赖 -->
           <dependency>
               <groupId>com.alibaba.cloud</groupId>
               <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
               <version>2023.0.1.3</version>
           </dependency>
   
           <!-- 用SpringCloud启动SpringBoot -->
           <dependency>
               <groupId>org.springframework.cloud</groupId>
               <artifactId>spring-cloud-starter-bootstrap</artifactId>
               <version>4.1.4</version>
           </dependency>
   ```

2. 然后去创建一个名为：**bootstrap**的yaml配置文件

   ```yaml
   spring:
     profiles:
       active: dev                     #说明为开发环境
     cloud:
       nacos:
         server-addr: 127.0.0.1:8848   #Nacos网址
         config:
           file-extension: json        #获取配置的格式
   ```

3. 然后修改一下项目里**application**的配置文件

   ```yaml
   spring:
     application:
       name: test2
   server:
     port: 8081
   ```

4. 然后在去到Nacos控制台中，创建配置![Nacos控制台](./3.微服务基础.assets/ad204a19-e843-4e80-ada7-745b7ceefa60.png)

5. 点击后根据图片的信息填写![Nacos](./3.微服务基础.assets/c0e2e7b5-069a-4fea-a559-06c14072ca7d.png)

6. 这里我我填写的是![Nacos](./3.微服务基础.assets/3036765a-c2e7-479d-b2eb-8ed40397de9c.png)

   1. 其中名字是：Gateway

   2. Json内容是

      ```json
      { 
        "id": "test2",
        "uri": "lb://test2",
        "predicates": [
          {
            "name":"Path",
            "args":{
              "_genkey_0":"/test1/**"
            }
          }
        ],
        "filters":[]
      }
      ```

7. 这里的信息和之前的网关配置文件差不多，可以回去查看琢磨，这里不过多阐述

8. 然后编写一个**配置文件类**

   ```java
   import com.alibaba.cloud.nacos.NacosConfigManager;
   import com.alibaba.nacos.api.config.listener.Listener;
   import jakarta.annotation.PostConstruct;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.cloud.gateway.route.RouteDefinition;
   import org.springframework.cloud.gateway.route.RouteDefinitionWriter;
   import org.springframework.stereotype.Component;
   import reactor.core.publisher.Mono;
   
   import java.util.ArrayList;
   import java.util.List;
   import java.util.concurrent.Executor;
   
   @Component  //标明配置文件类
   public class DynamicRouteLoader {
       @Autowired
       private NacosConfigManager nacosConfigManager;
       @Autowired
       private RouteDefinitionWriter writer;
   
       //记录路由ID
       private String routeId=null;
   
       //Nacos的配置文件名称
       private final String dataId = "Gateway";
       ////Nacos的配置文件分组
       private final String group = "DEFAULT_GROUP";
   
       /**
        * 初始化路由
        */
       @PostConstruct  //初始化后执行
       public void initRoute(){
           try {
               //项目启动时，拉取一次配置，然后进行监听
               String config=nacosConfigManager.getConfigService()
                       //其中参数1是配置名称
                       //参数2是配置分组
                       //参数3是超时时间
                       //参数4是设置
                       .getConfigAndSignListener(dataId,group,1000*5,
                       new Listener() {
                           //定义线程池，返回null就是没有
                           @Override
                           public Executor getExecutor() {
                               return null;
                           }
   
                           //配置变更，你要做干嘛？
                           @Override
                           public void receiveConfigInfo(String s) {
                               //如果变更，就更改路由参数
                               updataConfig(s);
                           }
                       });
               //监听到配置变更，就修改路由参数
               updataConfig(config);
           }catch (Exception e){
               e.printStackTrace();
           }
       }
   
       public void updataConfig(String configJson){
           //检查一下，从配置文件拉取的参数
           System.out.println("检查一下："+configJson);
           //由于这里接受的是一个集合
           //但是这个封装好的工具只会返回一个对象
           //因此这样实现
           List<RouteDefinition> a=new ArrayList<>();
           a.add(redisJson.getJson(configJson,RouteDefinition.class));
   
           //在修改网关配置之前，先删除旧的配置
          if(routeId!=null){
              writer.delete(Mono.just(routeId)).subscribe();
          }
   
           //提供一个响应式编程的容器,然后进行订阅响应式
           writer.save(Mono.just(a.get(0))).subscribe();
           //存入ID
           routeId=a.get(0).getId();
       }
   }
   ```

9. 代码很多，要好好看一遍

10. 然后启动项目，可以测试一下，如果能进去就说明拉取配置成功

11. 然后可以尝试**去Nacos修改一下配置文件**，修改后回来看idea控制台，**你会发现它监听配置文件变化**，已经获取到新的配置文件信息了

## *服务保护分布式事务

### 雪崩

**和Redis缓存雪崩类似**，因为一个小故障进而引发整个系统的故障

比如说如果一个系统有abcd四个业务，**假如abc三个业务都依赖于d的话**，那么**d业务一旦宕机**，那么abc三个业务都无法进行，相当于**整个系统都故障**

那么问题的关键在哪？问题的关键就是**调用者，没发现被调用者已经宕机故障，还在调用所导致的**

#### 解决方法

解决方法除了假大空的，提高代码质量、增加网络带宽这些以外，还有几种比较常见

1. **请求限流**：**限制微服务的请求并发量**，避免服务因流量暴增出现故障
2. **线程隔离**：也可以叫**舱壁模式**，通过限定业务能使用的线程数量，从而将故障业务隔离，避免故障扩散。简单来说，就是**进入这个服务，得先去线程池拿一条线程**，假如这时候服务故障，那你**业务没有完成，线程无法释放**，等线程池耗光后，其他地方进来，就因为**没有线程无法访问这个服务**
3. **服务熔断**：统计业务请求的异常比例和超时比例，超出阈值后熔断该业务，拦截该业务的请求接口，全部引导到另外一边进行业务补充

那么这些具体代码实现，都有一定难道，那么该怎么写了？

根本不用担心，因为Spring已经有对应的组件了，我们可以直接使用

### Sentinel

目前常见的实现库有Sentinel和Hystrix，其中前者为阿里巴巴后者为奈飞（看剧的那个）

这里将于Sentinel来完成

#### 控制台

**Sentinel**是一个**微服务流量控制组件**，并且提供一个web端的控制台 

1. 首先呢，我们先去[github](https://github.com/alibaba/Sentinel)上下载一个jar包下来，放在一个**非中文的目录**

2. 然后呢**在存放的目录下新建一个txt文件**，写上这段代码

   ```cmd
   java -jar sentinel-dashboard-1.8.8.jar --server.port=8090
   ```

   **注意**，其中的版本号要和吗下载的文件名对上，后面的端口号是因为默认8080，这个端口是给SpringBoot使用的，所以这里修改了端口号

3. 然后把txt改成cmd文件，运行cmd文件后，然后点击[控制台](http://localhost:8090/#/login)

4. 当你看见这个的时候，就说明稳了![控制台](./3.微服务基础.assets/a980dbe5-a264-434c-a9c7-6a7ee6cfb272.png)

5. 输入用户和密码

   ```
   sentinel
   ```

   **默认**账号和密码都是这个

6. 然后去到Idea中，在springboot项目下添加这个**Maven依赖**

   ```xml
           <!-- sentinel的依赖 -->
           <dependency>
               <groupId>com.alibaba.cloud</groupId>
               <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
               <version>2023.0.1.3</version>
           </dependency>
   ```

7. 然后在**该项目**下的配置文件添加和控制台连接的信息

   ```yaml
   spring:
     cloud:
       sentinel:
         transport:
           dashboard: localhost:8090   #控制台端口位置
           client-ip: 127.0.0.1        #控制台Ip地址
   
   ```

8. 随后开启这个项目，然后访问这个项目中任意一个接口（多访问几次），然后再回到Sentinel控制台中

9. 然后你就会看到这个页面![控制台](./3.微服务基础.assets/ee4a083c-0afd-4569-ba01-4802fd83dc73.png)如果没有，**耐心等待一小会**（五分钟)，再点刷新就能看见了，红圈圈中的，就是你的SpirngBoot项目名称

10. 到这就说明你Sentinel搭建成功

这里简单解释一下**簇点链路**，也被称为单机调用链路，是一次请求进入服务后，经过每一个被Sentinel监控的资源链，默认Sentinel会监控SpringMvc的每一个Endpoint（http接口）。限流、熔断等都是**对簇点链路中的资源设置**，而资源名默认就是接口的请求路径

- 再简单点来说，比如下面代码示例

  ```java
  @RestController
  @RequestMapping("test1")
  public class test1 {
      @PostMapping("1")
      public String test1(@RequestBody String name) {
          System.out.println(name);
          return "test2项目";
      }
  
      @GetMapping("2")
      public String test2(@RequestHeader(value = "sb",required = false) String sb) {
          return "路由配置成功";
      }
  }
  ```

  如果**你做限流、熔断等操作**，它会**直接把这个test1下的所有接口都给同步设置**，因为这个test1就是资源的默认名称

那现在问题来了，我不想你一竿子打翻一船人，我希望**针对某一接口进行操作**，那该怎么实现呢？

1. 答案其实很简单，只需要**在配置文件配置一下**

   ```yaml
   spring:
     cloud:
       sentinel:
         transport:
           dashboard: localhost:8090   #控制台端口位置
           client-ip: 127.0.0.1        #控制台Ip地址
         http-method-specify: true     #是否设置请求方式作为资源名称
   ```

2. 配置好重启项目，然后**把类中的所有接口都进去一次**，然后回到控制台，这样就能指定接口去做控制![控制台](./3.微服务基础.assets/820321b4-8919-4fe0-8150-f9ebf7a78273.png)这里的/error是因为类中的1接口需要post方式进入，因此这里显示的错误，但是不影响

#### 请求限流

请求限流就是字面意思，对请求访问进行限制

首先先了解两个概念

1. **QPS**：每秒访问次数
2. **并发线程数**：服务器会为请求创建多少个线程。

**通常我们会选择qps来做限制**

1. 如图所示，选择你要限流的接口，然后单机阈值就是**单台服务器能接受最大值qps**![控制台](./3.微服务基础.assets/d5f87c29-3e90-4c0e-99c0-bd163b3a5511.png)
2. 设置好后，就可以在**流控规则**看见你所设置的规则![8d7ed69d-38d9-4003-80e0-39333012b635](./3.微服务基础.assets/8d7ed69d-38d9-4003-80e0-39333012b635.png)
3. 然后这个时候去你所**限流好的接口**，**疯狂刷新**，你会发现有时候是会返回失败结果的，这就说明你的限流设置成功

#### 线程隔离

假如某个微服务中的业务，因未知原因导致速度缓慢，当大量请求进入的时候，都会阻塞在一起，当微服务的tomcat线程资源耗尽后，将导致整个微服务卡顿，这时候其他需要用到这个微服务的其他业务也会阻塞等待，导致整个系统的速度下降。

为了解决这个问题，我们需要进行**线程隔离**

线程隔离呢，就是**限定某个接口最多能用多少个线程**，避免因为单个接口拖累整个微服务

听起来挺复杂的，但其实一点都不简单。不过不要紧，**Sentinel已经实现好了**，我们只需要去**配置规则即可**

**和上面请求限流一样的方法**，只不过**把阈值类型改成了并发线程数**，然后配置能分配多少条线程就可以了，没错就是这么简单。

**注意！并发线程数假如处理完这个业务需要500ms，那么分配5条线程那一秒的qps为10。**

不过还是有东西要做，那就是**简单配置一下tomcat的线程数**，tomcat的默认最高线程数是200，可以根据计算机硬件水平进行修改

- 把这段代码写到配置文件中

  ```yaml
  server:
    tomcat:
      threads:
        max: 50             #最大线程数
      accept-count: 100     #允许等待的连接数
  ```

  **注意！**这里的**等待连接数**，**是指用户请求访问的数量**

#### fallback

虽然用线程隔离方法**，可以避免整个微服务和系统崩溃**，但是你这个**阻塞的服务依然无法使用**，这个问题又该怎么解决呢？

我们可以采用**fallback**方法去做一个兜底，当业务无法使用的时候，用户就走这个fallback，返回一些空数据或者默认数据，让用户体验更加友好

由于环境问题，相信后人[智慧](https://www.bilibili.com/video/BV1S142197x7?spm_id_from=333.788.player.switch&vd_source=95c95b2b45956217a529f886ca23dd35&p=76)

#### 服务熔断

如果现在微服务中的**某个接口非常卡顿**，这个时候应该**直接熔断这个接口**，而不是继续向它发送请求，当**服务恢复正常**的时候，就要**重新建立链接使用**。

而用来做熔断的东西叫做**断路器**，**根据超时时间和异常比例来做熔断**，但是这个**熔断是临时**的，**当熔断超时后，会重新进行一次访问**，如果还是故障状态，那么就会继续熔断，**一直循环**。

当然这个也只需要使用**Sentinel**就可以实现，不需要编码完成

- 这是Sentinel的熔断选项图![熔断](./3.微服务基础.assets/0fea8b8b-e513-4628-b54a-b532af0e1129.png)

这里简单解析一下这个规则的一些名称涵义

1. **慢调用比例**：多次调用的业务处理时间太慢
2. **异常比例**：根据业务的异常比例来决定
3. **异常数**：出现多少个业务异常来决定

当你选择**慢调用比例**的时候

1. **最大RT**：就是最大的响应时间，超过就算慢
2. **比例阈值**：慢速业务到达多少业务的百分比，就熔断服务器
3. **熔断时长**：熔断是临时的，这个熔断时长就是控制熔断多久
4. **最小请求数**：这是一个统计数量，到发送请求到达多少，我才开始统计慢速业务的比例
5. **统计时长**：这个是指统计多少时间内的慢速业务

根据你的业务需求填写好信息后，**添加规则即可实现熔断**

### 分布式事务

假设有这么一个场景：用户购买物品=>创建订单=>清理购物车=>扣除库存数量。

在以前单体项目的情况下，这个业务四个环节任何一个地方出现问题，都会回滚事务。

但是现在问题来了，我用微服务，把这个业务场景拆成四部分，这中间出异常了，该怎么回滚？各个微服务都是独立的服务器和配置，都是各玩各的

在很长一段时间内，这一直是个业界难题。但是现在时代发展，已经基本上解决这个难题了

#### Seata

这是一个2019年，阿里巴巴开源的一套分布式事务解决方案，主打**高性能**和**简单好用**

- Seata在业务中，充当事务协调者，如图所示![ppt](./3.微服务基础.assets/1f9e14b3-b5f2-4413-b993-45b00cfa9507.png)

好现在微服务的事务问题是解决了

可是问题又来了，那Seata它怎么知道一个业务流程要走的微服务链条是什么样的呢？

这个时候就要了解**Seata的事务管理的三个角色**

1. **TC**-事务协调者：负责全局事务提交或者回滚（**回滚还是提交**）
2. **TM**-事务管理器：定义全局事务范围，开始事务（**业务链条**）
3. **PM**-资源管理器：管理分支事务（**每个微服务的事务管理**）
4. 图解![图](./3.微服务基础.assets/f1359253-d303-46e7-ab26-9333f48f3d7e.png)

#### 部署TC服务

TC是一个负责事务回滚或者提交的角色，是**一个单独的服务**。

**注意！本次部署基于Windows**

1. 去[官网](https://seata.apache.org/unversioned/download/seata-server/)下载Seata，一定要下载圈住的**超链接**![1fb8f922-cb9e-4162-95a0-599051e4617c](./3.微服务基础.assets/1fb8f922-cb9e-4162-95a0-599051e4617c.png)

2. 下载好后，解压进到目录中，script=>server=>db找到**mysql.sql**文件

3. 然后打开数据库软件，创建一个架构（库）叫做**seata**，然后在这个库里面把刚才的mysql.sql文件里的代码全部运行一遍

4. 然后回到seata软件目录中，seata-server=>conf，找到**application.yml**文件

5. 点进去后把里面代码**全部删掉**（如果你不想删，你也可以对照着使用），然后复制这段数据

   ```yaml
   #
   # Licensed to the Apache Software Foundation (ASF) under one or more
   # contributor license agreements.  See the NOTICE file distributed with
   # this work for additional information regarding copyright ownership.
   # The ASF licenses this file to You under the Apache License, Version 2.0
   # (the "License"); you may not use this file except in compliance with
   # the License.  You may obtain a copy of the License at
   #
   #     http://www.apache.org/licenses/LICENSE-2.0
   #
   # Unless required by applicable law or agreed to in writing, software
   # distributed under the License is distributed on an "AS IS" BASIS,
   # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   # See the License for the specific language governing permissions and
   # limitations under the License.
   #
   
   server:
     port: 7091
   
   spring:
     application:
       name: seata-server
   
   logging:
     config: classpath:logback-spring.xml
     file:
       path: ${log.home:${user.home}/logs/seata}
     extend:
       logstash-appender:
         destination: 127.0.0.1:4560
       kafka-appender:
         bootstrap-servers: 127.0.0.1:9092
         topic: logback_to_logstash
   
   console:
     user:
       username: seata
       password: seata
   seata:
     config:
       # support: nacos, consul, apollo, zk, etcd3
       type: file
     registry:
       # support: nacos, eureka, redis, zk, consul, etcd3, sofa
       type: nacos                   #选择你的注册中心
       nacos:
         application: seata-server   #服务名称，对应nacos中显示的ID
         server-addr: 127.0.0.1:8848     #url地址
         group: "DEFAULT_GROUP"      #对应的nacos分组
         namespace: ""               #nacos的命令空间，如果你不填就默认是public(但你不能直接public)
         username: "nacos"           #账号
         password: "nacos"           #密码
     store:
       # support: file 、 db 、 redis 、 raft
       mode: db                #选择数据库
       session:
         mode: db              #session存放
       lock:
         mode: db              #锁存放
       db:
         datasource: druid     #数据库连接池
         db-type: mysql
         driver-class-name: com.mysql.cj.jdbc.Driver
         url: jdbc:mysql://localhost:3306/seata?useUnicode=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai
         user: root
         password: root
         vgroup_table: vgroup_table          #对应数据库里的表
         global_table: global_table          #对应数据库里的表
         branch_table: branch_table          #对应数据库里的表
         lock_table: lock_table              #对应数据库里的表
         distributed_lock: distributed_lock  #对应数据库里的表
         query-limit: 1000
         max-wait: 5000
     #  server:
     #    service-port: 8091 #If not configured, the default is '${server.port} + 1000'
     security:
       secretKey: SeataSecretKey0c382ef121d778043159209298fd40bf3850a017
       tokenValidityInMilliseconds: 1800000
       csrf-ignore-urls: /metadata/v1/**
       ignore:
         urls: /,/**/*.css,/**/*.js,/**/*.html,/**/*.map,/**/*.svg,/**/*.png,/**/*.jpeg,/**/*.ico,/api/v1/auth/login,/version.json,/health,/error,/vgroup/v1/**
   ```

6. 然后启动**Nacos服务**

7. 然后保存配置文件，去到软件目录，seata-server=>lib在这里，把**mysql驱动**(jar包)放在这里

8. 然后去到软件目录，seata-server=>bin目录下，新建一个**txt文件**，把下面代码复制进去

   ```bat
   @REM
   @REM Licensed to the Apache Software Foundation (ASF) under one or more
   @REM contributor license agreements.  See the NOTICE file distributed with
   @REM this work for additional information regarding copyright ownership.
   @REM The ASF licenses this file to You under the Apache License, Version 2.0
   @REM (the "License"); you may not use this file except in compliance with
   @REM the License.  You may obtain a copy of the License at
   @REM
   @REM     http://www.apache.org/licenses/LICENSE-2.0
   @REM
   @REM Unless required by applicable law or agreed to in writing, software
   @REM distributed under the License is distributed on an "AS IS" BASIS,
   @REM WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   @REM See the License for the specific language governing permissions and
   @REM limitations under the License.
   @REM
   
   @echo off
   
   chcp 65001
   
   set ERROR_CODE=0
   
   :init
   @REM Decide how to startup depending on the version of windows
   
   @REM -- Win98ME
   if NOT "%OS%"=="Windows_NT" goto Win9xArg
   
   @REM set local scope for the variables with windows NT shell
   if "%OS%"=="Windows_NT" @setlocal
   
   @REM -- 4NT shell
   if "%eval[2+2]" == "4" goto 4NTArgs
   
   @REM -- Regular WinNT shell
   set CMD_LINE_ARGS=%*
   goto WinNTGetScriptDir
   
   @REM The 4NT Shell from jp software
   :4NTArgs
   set CMD_LINE_ARGS=%$
   goto WinNTGetScriptDir
   
   :Win9xArg
   @REM Slurp the command line arguments.  This loop allows for an unlimited number
   @REM of arguments (up to the command line limit, anyway).
   set CMD_LINE_ARGS=
   :Win9xApp
   if %1a==a goto Win9xGetScriptDir
   set CMD_LINE_ARGS=%CMD_LINE_ARGS% %1
   shift
   goto Win9xApp
   
   :Win9xGetScriptDir
   set SAVEDIR=%CD%
   %0\
   cd %0\..\.. 
   set BASEDIR=%CD%
   cd %SAVEDIR%
   set SAVE_DIR=
   goto repoSetup
   
   :WinNTGetScriptDir
   set BASEDIR=%~dp0
   set BASEDIR=%BASEDIR:~0,-5%
   
   :repoSetup
   set REPO=
   
   
   if "%JAVACMD%"=="" set JAVACMD=java
   
   if "%REPO%"=="" set REPO=%BASEDIR%\lib
   
   set CLASSPATH="%BASEDIR%"\conf;"%REPO%"\*
   
   set ENDORSED_DIR=
   if NOT "%ENDORSED_DIR%" == "" set CLASSPATH="%BASEDIR%"\%ENDORSED_DIR%\*;%CLASSPATH%
   
   if NOT "%CLASSPATH_PREFIX%" == "" set CLASSPATH=%CLASSPATH_PREFIX%;%CLASSPATH%
   
   @REM Reaching here means variables are defined and arguments have been captured
   :endInit
   
   if exist %BASEDIR%/logs (
     echo "%BASEDIR%/logs"
   ) else (
     md "%BASEDIR%/logs"
   )
   
   if "%SKYWALKING_ENABLE%"=="true" (
     set SKYWALKING_OPTS=-javaagent:"%BASEDIR%"/ext/apm-skywalking/skywalking-agent.jar -Dskywalking_config="%BASEDIR%"/ext/apm-skywalking/config/agent.config -Dskywalking.logging.dir="%BASEDIR%"/logs
     echo "apm-skywalking enabled opts: %SKYWALKING_OPTS%"
   ) else (
     echo "apm-skywalking not enabled"
   )
   if "%JMX_ENABLE%"=="true" (
     set JMX_PORT=%JMX_PORT%
     set JMX_OPTS=%JMX_OPTS%
     if "%JMX_OPTS%"=="" (
       set "JMX_OPTS=-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false"
     )
     if "%JMX_PORT%"=="" (
       set "JMX_OPTS=%JMX_OPTS% -Dcom.sun.management.jmxremote.port=10055 -Dcom.sun.management.jmxremote.rmi.port=10055"
     )
     echo "JMX enabled"
   ) else (
     echo "JMX disabled"
   )
   
   %JAVACMD% %JAVA_OPTS% %SKYWALKING_OPTS% %JMX_OPTS% -server -Dloader.path="%BASEDIR%"/lib -Xmx1024m -Xms1024m -Xss512k -XX:SurvivorRatio=10 -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=256m -XX:MaxDirectMemorySize=1024m -XX:-OmitStackTraceInFastThrow -XX:-UseAdaptiveSizePolicy -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath="%BASEDIR%"/logs/java_heapdump.hprof -XX:+DisableExplicitGC -Xloggc:"%BASEDIR%"/logs/seata_gc.log -verbose:gc -Dio.netty.leakDetectionLevel=advanced -classpath %CLASSPATH% -Dapp.name="seata-server" -Dapp.repo="%REPO%" -Dapp.home="%BASEDIR%" -Dbasedir="%BASEDIR%" -Dspring.config.location="%BASEDIR%"/conf/application.yml -Dspring.config.additional-location="%BASEDIR%"/conf/ -Dlogging.config="%BASEDIR%"/conf/logback-spring.xml -jar "%BASEDIR%"/target/seata-server.jar %CMD_LINE_ARGS%
   if %ERRORLEVEL% NEQ 0 goto error
   goto end
   
   :error
   if "%OS%"=="Windows_NT" @endlocal
   set ERROR_CODE=%ERRORLEVEL%
   echo An error occurred. Error Code: %ERROR_CODE%
   pause
   goto end
   
   :end
   @REM set local scope for the variables with windows NT shell
   if "%OS%"=="Windows_NT" goto endNT
   
   @REM For old DOS remove the set variables from ENV - we assume they were not set
   @REM before we started - at least we don't leave any baggage around
   set CMD_LINE_ARGS=
   goto postExec
   
   :endNT
   @REM If error code is set to 1 then the endlocal was done already in :error.
   if %ERROR_CODE% EQU 0 @endlocal
   
   
   :postExec
   
   if "%FORCE_EXIT_ON_ERROR%" == "on" (
     if %ERRORLEVEL% NEQ 0 exit %ERROR_CODE%
   )
   
   exit /B %ERROR_CODE%
   ```

   这段代码，其实就是目录下的**启动程序的改版**，原版的启动程序异常就会直接闪退，根本看不到报错日志，这个文件**可以避免报错后直接闪退**

9. 接下来把txt文件改成bat，改一个能记住的名字，可以如图所示![目录](./3.微服务基础.assets/3efe7ba3-bf40-4921-82eb-7cff51036283.png)

10. 然后**启动seata-server.bat程序**，如果闪退，就尝试启动你刚才写好的bat程序

11. 当启动好后，去Nacos服务查看![Nacos](./3.微服务基础.assets/cab2dc80-13ec-4989-a539-ad9dcbfe5e89.png)

    当你看见这个后，稳了

12. 然后打开这个网址[Seata控制台](http://127.0.0.1:7091/#/transaction/list)，打开后账号密码都是

    ```
    seata
    ```

13. 然后点击这里切换中文![控制台](./3.微服务基础.assets/2a0a2343-c04d-48e2-a5aa-b013aafdaf39.png)

14. OK，TC服务搭建完成

#### 微服务Seata

现在TC是搭建好了，得让TC知道我们的微服务是哪个

由于Seata服务十分重要，因此往往会做成集群模式，拥有多个TC角色

那么什么微服务需要TC监管呢，答案当然业务微服务（注意！没有事务需求就别引入）

**注意，这里会把后面的XA模式和AT模式都将测试一遍**

1. 首先创建一个springboot的mvc项目

2. 然后在pom文件导入依赖

   ```xml
           <!-- springboot的mybatis依赖 -->
           <dependency>
               <groupId>org.mybatis.spring.boot</groupId>
               <artifactId>mybatis-spring-boot-starter</artifactId>
               <version>3.0.3</version>
           </dependency>
   
           <!-- mysql驱动 -->
           <dependency>
               <groupId>com.mysql</groupId>
               <artifactId>mysql-connector-j</artifactId>
               <version>8.4.0</version>
           </dependency>
   
           <!-- springboot的seata依赖 -->
           <dependency>
               <groupId>com.alibaba.cloud</groupId>
               <artifactId>spring-cloud-starter-alibaba-seata</artifactId>
               <version>2023.0.1.0</version>
           </dependency>
   ```

3. 然后在配置文件写入信息

   ```yaml
   spring:
     datasource:
       url: jdbc:mysql://localhost:3306/seata?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=UTC
       username: root
       password: root
       driver-class-name: com.mysql.cj.jdbc.Driver
     application:
       name: abc
   server:
     port: 8081
   
   seata:
     enabled: true                 # 是否开启事务
     tx-service-group: dcsp1       # 组名，主要是用来区分不同的微服务集群
     service:
       vgroup-mapping:
         dcsp1: default            # 定义TC的服务地址，单机模式下就是默认配置
       grouplist:
         default: 127.0.0.1:8091   #seata业务端口
     client:
       tm:
         commit-retry-count: 5     #当事务提交失败后，重试次数
     data-source-proxy-mode: XA    #设置事务模式
   ```

4. 然后随便写一个接口类和jdbc相关的类，这里留下的是接口类

   ```java
   import io.seata.spring.annotation.GlobalTransactional;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.web.bind.annotation.GetMapping;
   import org.springframework.web.bind.annotation.RequestMapping;
   import org.springframework.web.bind.annotation.RestController;
   
   @RestController
   @RequestMapping("/abc")
   public class mvc1 {
       @Autowired
       a1Dao a1Dao;
   
       @GetMapping("/abc")
       //下面的注释就是开启seata的事务
       @GlobalTransactional
       public String w(){
           a1Dao.deleteByid(1);
           if(true){int i=5/0;}
           return "abc";
       }
   }
   ```

5. 然后就可以启动测试,测试完成后切换事务模式为**AT**，然后在测试的库里导入一张表

   ```sql
   CREATE TABLE test1.undo_log (
       `id` bigint(20) NOT NULL AUTO_INCREMENT,
       `branch_id` bigint(20) NOT NULL,
       `xid` varchar(100) NOT NULL,
       `context` varchar(128) NOT NULL,
       `rollback_info` longblob NOT NULL,
       `log_status` int(11) NOT NULL,
       `log_created` datetime NOT NULL,
       `log_modified` datetime NOT NULL,
       PRIMARY KEY (`id`),
       UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`)
   ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
   ```

6. 然后继续测试一遍，没有问题说明整合完成

#### XA模式

XA规范是X/Open组织定义的**分布式事务标准**，也被称为两阶段模式。XA规范描述全局的TM与局部的RM之间的接口，几乎所有主流的关系型数据库都对XA规范提供支持

- 具体原理如图![图](./3.微服务基础.assets/39b930dc-c3c7-401f-8ecd-44c472f79a8b.png)

这种模式实现了事务的acid特性，但是这种模式在执行业务的时候，**会上排他锁**，也就是一次只能执行一个业务，**效率不高**

**注意！下面的执行步骤未做验证，相信后人智慧**

1. 首先在配置文件加上这句

   ```yaml
   seata:
     registry:
       type: nacos                         #选择你的注册中心
       nacos:
         server-addr: 127.0.0.1:8848       # url地址
         namespace: ""                     #nacos的命令空间，如果你不填就默认是public(但你不能直接public)
         group: "DEFAULT_GROUP"            #对应的nacos分组
         application: seata-server         #服务名称，对应nacos中显示的ID
         username: nacos                   #账号
         password: nacos"                  #密码
     tx-service-group: hmall               #集群组
     service:
       vgroup-mapping:
         hmall: "default"                  #组名
     data-source-proxy-mode: XA            #开启事务XA模式
   ```

2. 注意哦，要**所有参与事务的微服务都需要加上**

3. 然后在需要**参与事务方法**头（注意是头部）**加上这个注释**

   ```java
   import org.apache.seata.spring.annotation.GlobalTransactional;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.web.bind.annotation.GetMapping;
   import org.springframework.web.bind.annotation.RequestMapping;
   import org.springframework.web.bind.annotation.RestController;
   
   @RestController
   @RequestMapping("test1")
   public class test1 {
       @Autowired
       private com.zzz.apitest1.reqTest1 reqTest1;
   
       @GetMapping("1")
       //事务的头部
       @GlobalTransactional
       public String test1(){
           return "我成功获取到"+reqTest1.test("苹果");
       }
   }
   ```

4. 然后在参与事务的微服务上**加上maven依赖**（其实最好都加上）

   ```xml
           <!-- spring事务依赖 -->
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-data-jpa</artifactId>
               <version>3.3.4</version>
           </dependency>
   ```

5. 然后**参与事务的方法上**加上这个**注解**

   ```java
   import jakarta.transaction.Transactional;
   import org.springframework.web.bind.annotation.*;
   
   /**
    *
    * @author Akemi0Homura
    */
   @RestController
   @RequestMapping("test1")
   public class test1 {
       @PostMapping("1")
       //注解事务
       @Transactional
       public String test1(@RequestBody String name) {
           System.out.println(name);
           return name;
       }
   }
   ```

6. 然后就可以连接数据库进行测试

#### AT模式

AT模式同样也是**两阶段事务模型**，但是解决了XA模式的资源锁定周期过长的问题，**比XA效率更高**。

那具体是如何实现呢？

**XA模式**是等事务链中所有事务点都没问题，**一起提交**。而**AT模式**呢就是不用等大家，**直接提交**就可以了。

那如果提交的话，后面的业务出问题怎么办？答案是**XA模式会在执行业务之前**，先**生成一个数据库快照**，如果出错了，直接就用快照回滚即可。也就是**空间换时间**。当确**认这条事务链没有任何问题后，就删除之前生成的快照**

当然这种模式会出现**短时间**的**数据不一致**，比如说用户付款，付款业务提交后，显示付款成功，结果这时候突然下单业务出错，回滚数据库后，用户发现刚才说下单成功，结果购物车的商品根本没下单，造成体验问题

那么我究竟是选XA还是AT呢？有舍必有得，如果你能舍弃一致性就拥抱AT模式，如果要一致性就选择XA模式。**决定的因素是数据一致性**

**注意！下面的执行步骤未做验证，相信后人智慧**

1. **首先，这是基于XA模式的基础上进行修改**

2. 创建一个快照表

   ```sql
   create table undo_log
   (
   	branch_id bigint not null comment '分支事务 id',
   	xid varchar(100) not null comment '全局事务 id',
   	context varchar(128) not null comment 'undo_log context,such as serialization',
   	rollback_info longblob not null comment 'rollback info',
   	log_status int not null comment '0:normal status,1:defense status',
   	log_created datetime(6) not null comment 'create datetime',
   	log_modified datetime(6) not null comment 'modify datetime',
   	constraint ux_undo_log
   		unique (xid, branch_id)
   )
   comment 'AT transaction mode undo table' charset=utf8;
   ```

   注意哦，不同架构（库），**都需要一张这样的表**

3. 然后把配置文件中的**XA模式换成AT**就可以了

   ```yaml
   seata:
     registry:
       type: nacos                         #选择你的注册中心
       nacos:
         server-addr: 127.0.0.1:8848       # url地址
         namespace: ""                     #nacos的命令空间，如果你不填就默认是public(但你不能直接public)
         group: "DEFAULT_GROUP"            #对应的nacos分组
         application: seata-server         #服务名称，对应nacos中显示的ID
         username: nacos                   #账号
         password: nacos"                  #密码
     tx-service-group: hmall               #集群组
     service:
       vgroup-mapping:
         hmall: "default"                  #组名
     data-source-proxy-mode: AT            #开启事务AT模式
   ```

   是的，你没听错，就是这么简单（需要做数据库标记）
