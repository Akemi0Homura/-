# 创建者模式

## 学习帮助

[通义AI](https://tongyi.aliyun.com/)

## 何为创建者模式

就是如何创建对象，将**对象的创建与使用分离**

## * 单例模式

单例模式就是创建出来的对象，**始终都是同一个**

具体来说就是对象类，自己负责创建自己对象，提供一个方法给外部获取对象，这样外部可以直接访问对象，而不需要创建出来

### 饿汉式

系统刚运行的时候，单例对象就被创建出来

1. 饿汉单例模式代码如下

   ```java
   /**
    * 饿汉式单例模式，基于静态成员变量实现
    */
   public class Singleton {
       //类对象
       private static final Singleton instance = new Singleton();
   
       //私有构造方法,不让外界new出对象
       private Singleton() {
       }
   
       //提供一个公共方法，让外界获取里面的对象
       public static Singleton getInstance() {
           return instance;
       }
   }
   ```

2. **如果有必要的话**，可以修改一下向下面代码一样，**防止反射获取**

   ```java
   /**
    * 饿汉式单例模式，基于静态成员变量实现
    */
   public class Singleton {
       //类对象
       private static final Singleton instance = new Singleton();
       
   
       //私有构造方法,不让外界new出对象
       private Singleton() {
           //加上锁，避免多个线程跑进来
           synchronized (Singleton.class) {
               //反射强行获取的构造函数
               //如果对象已经创建好，给它个异常就老实了
               if(instance != null){
                   throw new RuntimeException("单例模式，禁止反射获取构造函数");
               }
           }
       }
   
       //提供一个公共方法，让外界获取里面的对象
       public static Singleton getInstance() {
           return instance;
       }
   }
   ```
   
3. 如果**真有必要**的话，可以再次修改下代码，防止**序列化**破坏单例模式

   ```java
   import java.io.Serial;
   import java.io.Serializable;
   
   /**
    * 饿汉式单例模式，基于静态成员变量实现
    * 实现了Serializable接口，这样该对象就能进行序列化操作
    */
   public class Singleton implements Serializable {
       //类对象
       private static final Singleton instance = new Singleton();
   
   
       //私有构造方法,不让外界new出对象
       private Singleton() {
           //加上锁，避免多个线程跑进来
           synchronized (Singleton.class) {
               //反射强行获取的构造函数
               //如果对象已经创建好，给它个异常就老实了
               if(instance != null){
                   throw new RuntimeException("单例模式，禁止反射获取构造函数");
               }
           }
       }
   
       //重写了序列化中的这个方法后
       //就可以避免序列化被强行new出来
       //破坏原本的单例模式
       @Serial
       public Object readResolve() {
           return getInstance();
       }
   
       //提供一个公共方法，让外界获取里面的对象
       public static Singleton getInstance() {
           return instance;
       }
   }
   ```

   虽然这个也不是**最完美**，但是基本上能用在**99%的业务场景**了

### 懒汉式

首次使用单例对象才会被创建

1. 懒汉式内部类单例模式

   ```java
   /**
    * 懒汉式，通过java的内部类特性单例模式
    */
   public class Singleton {
       //私有构造方法,不让外界new出对象
       private Singleton() {
       }
   
       //内步类在JVM虚拟机启动的时候，不会加载
       //只有调用的时候启动
       private static class SingletonHolder {
           private static final Singleton instance = new Singleton();
       }
   
       //提供一个公共方法，让外界获取里面的对象
       public static Singleton getInstance() {
           return SingletonHolder.instance;
       }
   }
   ```

2. **如果有必要的话**，可以修改一下向下面代码一样，**防止反射获取**

   ```java
   /**
    * 懒汉式，通过java的内部类特性单例模式
    */
   public class Singleton {
       //设置一个状态
       private static boolean flag = false;
   
       //私有构造方法,不让外界new出对象
       private Singleton() {
           //加个同步锁，避免下面修改flag值出问题
           synchronized (Singleton.class) {
               //检查你是第几次创建对象，如果部不是第一次就给你异常
               if(flag){
                   throw new RuntimeException("单例模式，禁止反射获取构造函数");
               }
               flag = true;
           }
       }
   
       //内步类在JVM虚拟机启动的时候，不会加载
       //只有调用的时候启动
       private static class SingletonHolder {
           private static final Singleton instance = new Singleton();
       }
   
       //提供一个公共方法，让外界获取里面的对象
       public static Singleton getInstance() {
           return SingletonHolder.instance;
       }
   }
   ```
   
3. 如果**真有必要**的话，可以再次修改下代码，防止**序列化**破坏单例模式

   ```java
   import java.io.Serial;
   import java.io.Serializable;
   
   /**
    * 懒汉式，通过java的内部类特性单例模式
    * 实现了Serializable接口，这样该对象就能进行序列化操作
    */
   public class Singleton implements Serializable {
       //设置一个状态
       private static boolean flag = false;
   
       //私有构造方法,不让外界new出对象
       private Singleton() {
           //加个同步锁，避免下面修改flag值出问题
           synchronized (Singleton.class) {
               //检查你是第几次创建对象，如果部不是第一次就给你异常
               if(flag){
                   throw new RuntimeException("单例模式，禁止反射获取构造函数");
               }
               flag = true;
           }
       }
   
       //内步类在JVM虚拟机启动的时候，不会加载
       //只有调用的时候启动
       private static class SingletonHolder {
           private static final Singleton instance = new Singleton();
       }
   
       //重写了序列化中的这个方法后
       //就可以避免序列化被强行new出来
       //破坏原本的单例模式
       @Serial
       public Object readResolve() {
           return getInstance();
       }
   
       //提供一个公共方法，让外界获取里面的对象
       public static Singleton getInstance() {
           return SingletonHolder.instance;
       }
   }
   ```

   虽然这个也不是**最完美**，但是基本上能用在**99%的业务场景**了

### 枚举式

枚举式又称恶汉式，之所以叫恶汉式，就是因为它相比前两种方法，太过可恶

通过**枚举类型**来实现单例模式，java中的枚举不需要考虑**线程安全**、**反射**、**序列化安全**等，并且十分简单。

**恶汉式是被请求调用时候才创建**

- ```java
  /**
   * 恶汉式，通过java的枚举来实现
   */
  public enum Singleton {
      instance;
  }
  ```

  你没看错，就是这么**简单**

### Web场景

在**网站开发**的场景中，每有一个用户进入服务器，Tomcat就会创建一个线程给用户

那么问题来了，不同的用户在它们对应的线程访问同一个单例模式对象，那对象里的数据是互相通用还是各自是各自的？

答案是**所有用户访问的都是同一个对象**

那么如果我想每**个用户使用的对象，都是不同的**，但是在**单个用户里这个对象是单例模式下**，那么这个该如何解决呢？

答案是**不需要解决**，因为这个需求显然是**违背了单例模式的原则**，因此在**这种需求下应该选择其他的技术**，比如说**Session和Cookie**，**Redis缓存**，**ThreadLocal线程变量**等来**满足**这个**需求**，而不是对这个单例模式去**钻牛角尖**
